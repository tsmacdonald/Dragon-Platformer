#/usr/bin/env python

# Notes: 
#

import os, pygame, creatures, levels, engine, controls, things
from utils import Vector
from pygame.locals import *
from constants import *
if DEBUG: import pdb

if not pygame.font: print 'Warning, fonts disabled'
if not pygame.mixer: print 'Warning, sound disabled'

def deal_with_keys(key, player, projectiles):
    window_offset = 0
    #Movement
    if key[controls.RIGHT]:
        player.go_right()
    elif key[controls.LEFT]:
        player.go_left()
    else:
        player.stand_still()
    #Shooting
    if key[controls.SHOOT]:
        player.fire(projectiles, "down" if key[controls.DOWN] else None)
        player.reload_wait = .45
    else:
        player.reload_wait = .16
    #Jumping        
    if key[controls.JUMP]:
        player.jump()
    if key[controls.FLAP]:
        player.flap()
    else:
        player.unflap()
    #Looking
    if player.velocity.x == 0 and player.landed:
        if key[controls.LOOK_DOWN]:
            window_offset += 12
        if key[controls.LOOK_UP]:
            window_offset -= 11
    else:
        window_offset = 0
#    if not key[controls.LOOK_DOWN] and not key[controls.LOOK_UP]:
#        print "yay"
#        if window_offset > 0:
#            window_offset = 5
#        if window_offset < 0:
#            window_offset = -5
    return window_offset

def message(text, color, size, font, position, screen, point = "topleft"):
    if pygame.font:
        font = pygame.font.Font(font, size)
        text = font.render(text, True, color)
        rect = text.get_rect()
        exec("rect.%s = position"%point)
        screen.blit(text, rect)
    else: print "No font! Can't display text in HUD."

def draw_HUD(screen, player, clock):
    message(str(player.points), (255, 0, 0), 36, None, (0, 0), screen) 
    message(str(player.shots), (255, 0, 0), 36, None, (0, 20), screen)
    message(str(player.lives), (255, 0, 0), 36, None, (0, 40), screen)
    message(str(int(clock.get_fps())), (255, 0, 0), 36, None, (0, 60), screen)

def kill_player(player, level, level_list, active_things, engine, window, screen):
    #active_things.empty(); active_things.add(player)
    #level.creatures.empty()
    #level.platforms.empty()
    level = level_list.same_level()
    engine.level = level
    engine.player = player
    player.position.topleft = level.starting_pos
    player.velocity.x = player.velocity.y = 0
    player.jumping = False
    player.lives -= 1
    if player.lives < 0:
        message("Game Over!",
                (255, 0, 0), 36, None, (window.width / 2, window.height / 2),
                screen, "center")
        pygame.display.flip()
        pygame.time.wait(1 * 3000)
        import sys; sys.exit(0)
    else:
        message("You have died!",
                (255, 0, 0), 36, None, (window.width / 2, window.height / 2),
                 screen, "center")
        pygame.display.flip()
        pygame.time.wait(1 * 2000)
        player.dead = False #Resurrection!
    return level


    

def main():
    """This function is called when the program starts.
       it initializes everything it needs, then runs in
       a loop until the function returns."""
       
    pygame.init()
    screen = pygame.display.set_mode()
    WIDTH, HEIGHT = screen.get_width(), screen.get_height()
#    screen = pygame.display.set_mode((WIDTH, HEIGHT))
#    pygame.display.toggle_fullscreen()
    pygame.display.set_caption(TITLE)
    pygame.mouse.set_visible(False)

    
    #Game Objects:
    window = pygame.Rect(0, 0, WIDTH, HEIGHT)
    clock = pygame.time.Clock()
    
    player = creatures.Player("new_dragon.png", position = [0, HEIGHT], velocity = [0, 0])
    
    active_things = pygame.sprite.Group(player)
    friendly_projectiles = pygame.sprite.Group()
    enemy_projectiles = pygame.sprite.Group()

    level_list = levels.LevelList()
    level = level_list.next_level()
    level = levels.Level("level1")
    level.set_starting_position(player)
    eng = engine.Engine(player, level, friendly_projectiles, enemy_projectiles)
    active_tiles = pygame.sprite.Group()
    motion_counter = 0
    creatures_moving = False

    pygame.display.flip()

    #player.jump() #Otherwise he might fall through the floor at the very beginning. Don't worry about it.
    
    max_height = player.position.y
    min_height = player.position.y
    window = pygame.Rect(max(player.position.x - (WIDTH / 2), 0), #x
                         player.position.bottom - HEIGHT + VERT_BUFFER, #y
                         WIDTH, HEIGHT)
#Main Loop
    while True:
#        max_height = min(player.position.y, max_height)
#        min_height = max(player.position.y, min_height)
        clock.tick(FPS)
        
        #Fix window / active creatures/things
        active_things.empty()

        if creatures_moving == False and motion_counter < 10:
            motion_counter += 1
        if motion_counter >= 9 and creatures_moving == False:
            for creature in level.creatures:
                creature.velocity.x = creature.default_velocity.x
                creature.velocity.y = creature.default_velocity.y
                creature.acceleration.y = GRAVITY
            creatures_moving = True
 
        window_offset = deal_with_keys(pygame.key.get_pressed(), player, friendly_projectiles)        
        window.y += window_offset
       
        potential_bottom = player.position.bottom + VERT_BUFFER
        if player.landed:
            if window.bottom > potential_bottom:
                window.bottom -= 0
            if window.bottom < potential_bottom:
                window.bottom += 0
        if True:#else
            if True:#player.down_p():
                window.bottom = max(potential_bottom, window.bottom)

        window.left = max(player.position.centerx - (WIDTH / 2), 0)
        window.right = min(window.right, level.width)
        window.top = min(window.top, player.position.top - (HEIGHT / 6))
        window.top = max(window.top, 0)
#        window.top = min(window.top, window.top - (HEIGHT / 4) * player.position.top)
        #window.bottom = min(window.bottom, level.height)
        
        for thing in (level.creatures.sprites() + [player] + friendly_projectiles.sprites() +
                      enemy_projectiles.sprites() + level.powerups.sprites() + [level.exit]):
             if thing.position.colliderect(window):
                active_things.add(thing)

       # Collision with powerups
        for thing in level.powerups.sprites():
            if thing.position.colliderect(player.position):
                thing.use(player)
                level.powerups.remove(thing)
        for projectiles in friendly_projectiles, enemy_projectiles:
            for bullet in projectiles.sprites():
                for platform in level.platforms.sprites():
                    if not isinstance(platform, things.InvisiblePlatform) and bullet.position.colliderect(platform.position):
                        projectiles.remove(bullet)
 
        #Check for death / completion
        level.creatures.remove(filter(lambda x: x.dead, level.creatures))
        if player.dead:
            level = kill_player(player, level, level_list, active_things, eng, window, screen)
            creatures_moving = False
            motion_counter = 0
        key = pygame.key.get_pressed()
        if (key[controls.SKIP] and not skipping) or player.position.colliderect(level.exit.position):
            skipping = True
            active_things.empty(); active_things.add(player)
            level.creatures.empty()
            level.platforms.empty()
            level = level_list.next_level()
            eng.level = level
            eng.player = player
            player.position.topleft = level.starting_pos
            player.velocity.x = player.velocity.y = 0
            player.jumping = False
            creatures_moving = False
            motion_counter = 0
            continue
        else:
            skipping = False

        #Input
        for event in pygame.event.get():
            if event.type == QUIT:
                return
        

        #Update
        # Gives the creatures and platforms a chance to do something cool.
        # Currently, all that means is that they set their relative position
        active_things.update(window, enemy_projectiles)
        level.platforms.update(window)
        #level.background.set_relative_position(window)
        
        #Collision detection / physics / etc.
        time = clock.get_time()
        eng.update(time) 

        player.tick(time)

       #Draw Everything
        #pygame.sprite.Group(level.background).draw(screen)
        active_tiles.empty()
        for tile in level.tiles.sprites():
            if tile.position.colliderect(window):
                active_tiles.add(tile)
        active_tiles.update(window)
        active_tiles.draw(screen)
        #print clock.get_fps()
        level.platforms.draw(screen)
        active_things.draw(screen)
        draw_HUD(screen, player, clock)
        pygame.display.flip()

#Game Over


if __name__ == '__main__':
    main()
    #import cProfile as profile
    #profile.run("main()")
